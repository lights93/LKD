Registering an Interrupt handler

	Interrupt handlers are the responsibility of the driver managing the hardware

	Drivers can register an interrupt handler and enable a given interrupt line for handling with the function request_irq()

	int request_irq(unsigned int irq: interrupt number,
					irq_handler_t handler: function pointer to the actual interrupt handler,
					unsigned long flags,
					const char *name: ASCII text representation of hte device associated with interrupts,
					void *dev: used for shared interrupt lines)

Interrupt Handler Flags

	IRQF_DISABLED	- when set, this flag instructs the kernel to disable all interrupts when executing this interrupt handler
					- when unset, interrupt handlers run with all interrupts except their own enabled
					- its use is reserved for performance-sensitive interrupts that execute quickly

	IRQF_SAMPLE_RANDOM	- interrupts generated by this device should contribute to the kernel entropy pool

						- when specified, the timing of interrupts from this device are fed to the pool as entropy

	IRQF_TIMER - this handler processes interrupts for the system timer

	IRQF_SHARED	- the interrupt line can be shared among multiple interrupt handlers

				- each handler registered on a given line must specify this flag
				otherwise, only one handler can exist per line

	dev parameter	- without this parameter it would be impossible for the kernel to know which handler to remove on a given interrupt line

					- passed into the interrupt handler on each invocation

	On success, request_irq() returns 0
	non-zero value indicates an error, in which case the specified interrupt handler was not registered

	request_irq() can sleep and therefore cannot be called from interrupt context or other situations where code cannot block(????????????)

Freeing an Interrupt Handler

	when driver unloads, you need to unregister interrupt handler and potentially disable the interrupt line

	void free_irq(unsigned int irq, void *dev)
		- if the specified interrupt is not shared, this function removes the handler and disable the line

		- if the interrupt line is shared, the handler identified via dev is removed,
		but the interrupt line is disabled only when the last handler is removed

		- call to free_irq() must be made from process context